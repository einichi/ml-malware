from starlette.applications import Starlette
from starlette.responses import JSONResponse, HTMLResponse, RedirectResponse, PlainTextResponse
from starlette.templating import Jinja2Templates
from pathlib import Path
from io import BytesIO
from PIL import Image as PillowImage
from fastai.vision import *
import torch
import sys
import uvicorn
import aiohttp
import asyncio
import imghdr
import base64
import numpy

async def get_bytes(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.read()

page = { 'title': "Machine Learning Malware Identifier" }

templates = Jinja2Templates(directory='templates')

app = Starlette(debug=True)

@app.route("/upload-file", methods=["POST"])
async def upload_file(request):
    data = await request.form()
    file_bytes = await (data["file"].read())
    img_bytes = file_to_image(file_bytes)
    return templates.TemplateResponse('result.html', {'request': request, 'result': predict_image(img_bytes)})

@app.route("/upload-url", methods=["GET"])
async def upload_url(request):
    file_bytes = await get_bytes(request.query_params["url"])
    img_bytes = file_to_image(file_bytes)
    return templates.TemplateResponse('result.html', {'request': request, 'result': predict_image(img_bytes)})

def file_to_image(bytes):
    w, h = 90, 90
    # There's definitely a better way to do this. Set it too high and small files will not get processed. Set it too low and it will get lossy for bigger files.
    # Since all images should be resized to the same size in the end for ML analysis, perhaps generate images of dynamic size then resize them all to an efficient size.
    d = numpy.frombuffer(bytes,dtype=numpy.uint8,count=w*h).reshape(h,w)
    PILimage = PillowImage.fromarray(d)
    iBytes = io.BytesIO()
    PILimage.save(iBytes, format='PNG')
    return iBytes.getbuffer()

def predict_image(bytes):
    mdl = Path('.')
    learn = load_learner(mdl)
    img = open_image(BytesIO(bytes))
    # run image through ML model generated in the jupyter notebook
    _,_,losses = learn.predict(img)
    # serialise and output prediction result and base64 representation of image of file for display in browser
    result = {
        'predictions': sorted(
            zip(learn.data.classes, map(float, losses)),
            key=lambda p: p[1],
            reverse=True
        ),
        'image': [
            ('data', base64.b64encode(bytes).decode('utf-8')),
            ('type', 'png'),
        ]
    }
    return result

@app.route("/")
def form(request):
    return templates.TemplateResponse('index.html', {'request': request})

@app.route("/form")
def redirect_to_homepage(request):
    return RedirectResponse("/")


if __name__ == "__main__":
    uvicorn.run("malware:app", host="127.0.0.1", port=8000)
